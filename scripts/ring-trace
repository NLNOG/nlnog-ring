#! /usr/bin/env python
"""
 ring-trace     perform a series of mtr's towards one destination
                and visualise the results by generating an image

 Author:        Teun Vink  - teun@teun.tv
 Requirements:  dnspython, graphviz, argparse, ipcalc
"""

import sys, os, threading, tempfile, time, random, re, operator, itertools

try:
    from dns.resolver import query
    from dns import name, reversename
    from dns.exception import DNSException
    import argparse
    from ipaddr import IPv4Address, IPv6Address, IPv4Network, IPv6Network
except:
    print "ERROR: one or more of the following python packages is missing:"
    print "dnspython, argparse, ipaddr\n"
    print "On Ubuntu: apt-get install python-dnspython python-argparse python-ipaddr"
    sys.exit(1)

VERSION="1.3.1 - written by Teun Vink <teun@teun.tv>"
DEBUG=0

colors = []

ixps4 = [
    "195.69.144.0/22",          # AMS-IX
    "80.81.192.95/22",          # DE-CIX
    "195.66.224.0/22",          # LINX
    "193.239.116.33/23",        # NL-ix
    "193.109.219.0/24",         # Lipex
    "193.203.5.0/24",           # Lonap
   "206.223.115.0/24", #Equinix Ashburn
   "206.223.119.0/25",	#Equinix Chicago
   "206.223.118.0/25",	#Equinix Dallas
   "206.223.123.0/25",	#Equinix Los Angeles
   "206.223.119.0/24",	#Equinix San Jose
   "198.32.176.0/24",	#Equinix Palo Alto
   "198.32.182.0/24",	#Equinix Atlanta
   "198.32.190.0/24",	#Equinix Vienna, VA
   "198.32.134.0/24",	#Equinix Seattle
   "198.32.118.0/24",	#Equinix New York
   "198.32.180.0/24",	#SIX
   "198.32.160.0/24",	#NYIIX
   "198.32.187.0/24",	#MAE East
   "198.32.200.0/24",	#MAE West
   "198.32.124.0/23",	#NOTA
   "198.32.139.0/24",	#MAE Central
   "198.32.212.0/24",	#WAIX
   "198.32.132.0/24",	#Telx Atlanta
   "198.32.146.0/24",	#LAIIX
   "198.32.245.0/24",	#TorIX
   "198.32.178.0/24",	#MXP
   "194.42.48.0/24",	#Equinix Zurich
   "198.32.129.0/24",	#SFIX
   "192.65.185.0/24",	#CIXP
   "194.68.129.0/24",	#SFINX
   "217.29.66.0/24",	#MIX-IT
   "213.228.3.128/25",	#FreeIX
   "198.32.247.0/24",	#PARIX
   "198.32.229.0/24",	#NYCX
   "202.40.161.0/24",	#HKIX
   "210.62.255.0/24",	#TWIX
   "202.0.91.0/24",	#Manila IX
   "193.1.29.192/27",	#INEX LAN1
   "193.203.0.0/25",	#VIX
   "217.79.160.0/23",	#XchangePoint
   "192.145.251.0/24",	#KINX
   "193.188.137.0/24",	#BiX
   "193.25.170.0/23",	#RBIEX
   "212.121.32.0/19",	#Edge-IX
   "195.85.203.0/24",	#FreeBIX
   "194.53.172.0/25",	#BNIX
   "194.242.34.14/25",	#SwissIX
   "213.234.0.0/25",	#CATNIX
   "193.149.0.0/24",	#ESPANIX
   "198.32.131.0/24",	#KD-X
   "80.67.175.0/26",	#Pouix
   "195.140.149.129/25",	#FNIX6
   "194.153.157.192/26",	#Lyonix
   "194.68.123.0/24",	#NetNod Stockholm
   "194.68.128.0/24",	#NetNod Stockholm
   "194.50.100.0/24",	#NIX CZ
   "194.59.190.0/24",	#INXS
   "213.238.34.0/24",	#WORK-IX
   "193.111.172.0/24",	#GN-IX
   "193.168.127.0/24",	#LIX
   "192.38.7.0/24",	#DIX
   "198.17.46.0/24",	#SD-NAP
   "207.231.241.0/24",	#PacificWave
   "193.156.90.0/24",	#NIX
   "192.108.148.0/24",	#SIX.SK
   "193.108.98.0/24",	#NDIX
   "193.178.185.0/24",	#B-CIX
   "210.184.127.0/24",	#iAIX
   "144.92.233.224/28",	#MadIX
   "195.245.196.0/24",	#MAD-IX
   "194.146.118.0/24",	#ECIX Duesseldorf
   "202.167.228.0/24",	#Equinix Sydney
   "195.85.195.0/24",	#WIX
   "195.242.64.0/23",	#UNION IXP
   "193.232.244.0/22",	#MSK-IX
   "218.100.2.0/24",	#PIPE Networks Sydney
   "194.85.177.0/24",	#SPB-IX
   "69.51.84.0/26",	#NWIX Helena
   "69.51.84.128/26",	#NWIX Missoula
   "218.100.0.0/24",	#PIPE Networks Brisbane
   "218.100.13.0/24",	#PIPE Networks Melbourne
   "218.100.19.0/24",	#PIPE Networks Canberra
   "218.100.12.0/24",	#PIPE Networks Hobart
   "194.116.96.0/19",	#TOP-IX
   "62.35.254.0/24",	#PaNAP
   "193.201.28.0/23",	#NaMeX
   "192.77.55.0/25",	#QiX 3
   "193.189.82.0/24",	#KleyReX
   "198.32.146.0/24",	#CIIX (formerly LAAP)
   "218.100.6.0/24",	#BBIX
   "198.32.162.0/24",	#OIX
   "193.110.12.0/24",	#SOL-IX / SOLIX
   "193.110.13.0/24",	#SOL-IX / SOLIX
   "193.108.17.0/24",	#SOL-IX / SOLIX
   "198.32.142.0/24",	#JINX
   "198.32.185.0/24",	#PHX-IX
   "195.85.217.0/24",	#N-IX
   "198.32.198.0/24",	#TampaIX
   "206.223.143.0/24",	#CoreSite - Any2 Los Angeles
   "194.165.32.0/24",	#GIX Gothenburg
   "80.67.163.0/24",	#GEIX
   "198.32.238.0/24",	#BigApe
   "208.50.192.0/24",	#IXNM
   "202.78.121.0/24",	#BAYANTEL
   "83.245.126.0/30",	#PacketExchange
   "85.31.223.0/24",	#MA-IX
   "195.60.84.128/25",	#MerieX
   "198.32.195.0/24",	#NWAX
   "83.245.126.0/23",	#eXpress
   "203.190.230.0/24",	#Equinix Tokyo
   "198.32.252.0/24",	#AMPATH
   "194.54.92.0/25",	#OCIX Duesseldorf
   "194.50.181.0/24",	#STHIX
   "200.0.17.0/24",	#CABASE
   "194.116.188.0/24",	#TIX-LAN
   "195.137.179.0/24",	#TLLIX
   "194.68.130.0/24",	#Netnod Gothenburg
   "195.69.116.0/24",	#Netnod Gothenburg
   "195.69.117.0/24",	#Netnod Malmö
   "195.69.118.0/24",	#Netnod Malmö
   "194.68.133.0/24",	#Netnod Sundsvall
   "194.68.135.0/24",	#Netnod Sundsvall
   "206.223.127.0/25",	#PIX Vancouver
   "206.223.139.0/26",	#PIX Montreal
   "206.223.127.128/25",	#PIX Toronto
   "198.32.202.0/24",	#NIXI Delhi
   "192.168.100.0/24",	#YRIX
   "206.51.40.0/24",	#CoreSite - Any2 DC
   "206.51.44.0/24",	#CoreSite - Any2 Miami
   "78.41.189.128/26",	#PhibIX
   "202.125.128.0/19",	#PTCL (PIE)
   "193.189.130.0/24",	#ENLIX
   "194.9.117.0/24",	#ECIX Berlin
   "218.100.4.0/24",	#IIX
   "198.32.167.0/24",	#BDIX
   "198.32.235.0/24",	#OttIX
   "193.232.87.0/24",	#NSK-IX
   "206.51.43.0/24",	#CoreSite - Any2 Chicago
   "198.32.172.0/24",	#PHOpenIX
   "193.4.58.0/27",	#RIX
   "193.84.179.0/24",	#PIX - Poznan
   "193.243.183.64/26",	#MalmIX Malmo / IXOR
   "80.248.213.128/27",	#StuffIX Paris
   "202.249.38.0/24",	#NSPIXP3
   "218.100.48.0/24",	#NIXI Chennai
   "198.32.143.0/24",	#KIXP
   "202.97.10.0/24",	#CNC Beijing NAP
   "198.32.149.0/24",	#Ottawa GigaPOP
   "206.51.33.0/24",	#ChIX
   "92.60.70.0/24",	#MINAP Milan
   "198.32.231.0/24",	#npIX
   "80.81.202.0/24",	#ALP-IX
   "206.51.7.0/24",	#KCIX Kansas City
   "218.100.44.0/24",	#MyIX
   "206.223.124/24",	#NAP Colombia - CCIT
   "200.1.6.0/24",		#NAP.EC
   "198.32.216.0/24",	#RMIX Denver
   "195.42.144.0/24",	#Equinix Paris
   "198.32.186.0/24",	#Telx Phoenix
   "194.68.131.64/26",	#Netnod Lulea
   "212.32.128.0/25",	#Norrnod
   "200.0.22.0/23",	#OCIX
   "198.180.153.0/24",	#SISPA
   "195.182.218/23",	#PLIX
   "206.197.210.0/24",	#DRF IX
   "218.100.50.0/25",	#TransACT IX
   "86.104.125.0/24",	#INTERLAN
   "193.42.140.0/24",	#TIX
   "81.21.96.0/24",	#CAIX
   "192.168.255.0/24",	#BY-IX
   "189.45.5.0/24",	#PTTMETRO Botafogo
   "196.223.7.0/24",	#MEIX
   "195.189.188.0/25",	#UppRIX
   "195.189.189.0/25",	#UppRIX
   "195.189.188.128/25",	#UppRIX
   "195.60.93.0/26",	#Crimea-IX
   "218.100.59.0/24",	#ACTIX
   "193.42.155.0/24",	#ECIX Hamburg
   "194.107.117.0/24",	#Od-IX
   "202.158.0.0/17",	#CBN Exchange Point
   "82.148.16.0/24",	#NET-IX
   "193.156.120.0/24",	#NIX2
   "194.30.187.0/24",	#Sitelix
   "217.156.113.0/24",	#RoNIX
   "193.192.15.64/26",	#CIX
   "212.5.48.0./22",	#SofiaConn
   "200.219.144.0/24",	#PTTMETRO Londrina
   "2001:7f8:4d::/48",	#ExWest
   "193.2.141.0/24",	#SIX SI
   "89.40.130.0/24",	#TomIX
   "114.141.48.0/21",	#CyberPlus
   "195.140.192.0/24",	#TREX
   "91.213.73.0/24",	#CNIX
   "193.169.198.0/23",	#BIX.BG
   "195.2.230.0/23",	#KAZ-IX
   "91.213.236.0/24",	#TOUIX
   "206.51.41.0/24",	#CoreSite - Any2 Silicon Valley
   "83.217.20.0/26",	#ULN-IX
   "93.156.93.0/24",	#TRDIX
   "198.32.214.0/24",	#CINX
   "189.76.208.0/20",	#WKVE
   "83.212.8.0/23",	#GR-IX
   "194.85.107.0/24",	#EKT-IX
   "192.77.55.0/24",	#QIX
   "78.111.112.0/20",	#GRAPESC
   "93.91.144.0/20",	#GRAPESC
   "109.72.0.0/20",	#GRAPESC
   "188.227.0.0/22",	#dataix
   "196.223.5.0/25",	#TIX - Tanzania
   "209.33.201.176/28",	#SUPRnet
   "195.246.227.0/24",	#SMILE-LV
   "200.0.20.0/23",	#CAR-IX
   "193.136.251.96/27",	#GigaPix OPorto
   "218.100.27.0/24 ",	#OpenIXP / NiCE
   "218.100.36.0/24",	#OpenIXP / NiCE
   "193.37.144.0/24",	#AAIX
   "193.232.136.0/24",	#VLV-IX
   "193.232.135.0/24",	#SMR-IX
   "193.232.140.0/24",	#RND-IX
   "193.57.253.128/27",	#REUNIX
   "62.63.140.0/22",	#LIX-LV
   "194.88.240.0/25",	#INEX LAN2
   "193.17.78.0/24",	#MD-IX
   "192.114.62.0/23",	#IIX_
   "204.228.158.0/27",	#UTOPIA
   "194.190.119.0/24",	#KZN-IX
   "193.219.13.64/26",	#LIPTAM
   "216.72.175.0/24",	#NAP Chile
   "91.216.67.0/24",	#FR-IX
   "202.85.224.0/20",	#Powernetix
   "196.223.1.0/24",	#Angola-IXP / ANG-IXP
   "194.153.153.0/24",	#UIXP
   "193.105.163.0/24",	#SOX d.o.o. Serbia
   "198.32.136.0/24",	#NASA-AIX
   "198.32.153.0/24",	#NASA-AIX
   "198.9.201.0/24",	#NASA-AIX
   "198.9.202.0/24",	#NASA-AIX
   "218.100.70.0/24",	#SGIX
   "193.105.214.0/24",	#GraX
   "218.100.41.0/24",	#BIXc
   "91.198.176.0/24",	#Fixo
   "194.117.52.128/25",	#COPHIX
   "119.110.116.0/23",	#MCIX - Matrix Networks
   "91.212.9.0/24",	#KIX
   "91.192.104.0/23",	#Lviv-IX
   "206.223.120.0/24",	#AZIX
   "195.60.89.0/25",	#CBIX
   "212.91.0.0/22",	#Thinx
   "195.149.232.0/21",	#TP-IX
   "196.216.148.0/24",	#IXPN Lagos
   "195.191.170.0/23",	#EPIX
   "195.149.232.0/23",	#TPIX
   "188.116.45.0/24",	#GIX Gdansk
   "193.28.6.0/24",	#PIRIX
   "218.100.78.0/24",	#VIC-IX
   "206.197.131.0/24",	#COIX
   "196.223.24.0/24",	#LIXP
   "192.168.10.0/24",		#MOZIX
   "217.117.187.0/24",	#KRS-IX
   "80.81.201.0/24",	#DE-CIX Düsseldorf
   "193.105.116.0/24",	#Content-IX
   "213.184.52.0/24",	#RTIX
   "81.16.231.0/25",	#Litix
   "91.232.229.0/24",	#Rheintal IX
   "200.219.144/22",	#PTTMETRO Salvador
   "192.108.145.0/24",	#SIX.SK Kosice
   "206.123.7.0/24",	#JXIX
   "206.108.236.0/24",	#Boston Internet Exchange
   "218.100.21.0/24",	#PNIX
    
]

ixps6 = [
    "2001:7f8::/29",            # generic IXP
]


class TraceThread(threading.Thread):

    def __init__(self, host, destination, user, proto, udp, timeout):
        self.starttime = time.time()
        self.host = host
        self.dest = destination
        self.user = user
        self.proto = proto
        self.udp = udp
        self.timeout = timeout
        self.result  = ""
        threading.Thread.__init__(self)

    
    def run(self):
        # run the mtr command
        cmd = "ssh %s -o ConnectTimeout=%d %s %s.ring.nlnog.net \"mtr %s --report-wide -c1 -r -n %s %s\"" % (
            "-v" if DEBUG > 1 else "",
            self.timeout,
            "-l %s" % self.user if self.user != "" else "",
            self.host, self.proto, 
            "-u" if self.udp else "",
            self.dest,
        )
        f = os.popen(cmd)
        lines = [l.strip() for l in f.readlines()][1:]
        f.close()

        # lookup the IP for the host
        qstr = "%s.ring.nlnog.net" % self.host
        qtype = "A"

        # IPv6 literal or forced IPv6
        if (":" in self.dest) or (self.proto == "-6"):
            qtype="AAAA"

        # check if the host has an AAAA record
        if qtype == "A":
            try:
                query(self.dest, "AAAA")
                qtype = "AAAA"
            except:
                qtype = "A"

        try:
            qres = query(qstr, qtype)
        except:
            qres = [qstr]

        # add the host as first hop so the graphs are easier to understand
        lines.insert(0, "0. %s" % qres[0]) 

        self.result = lines

        debug("host %s done in %.1f seconds." % (self.host, time.time() - self.starttime))


    def get_result(self):
        return self.result


def fix_dest(dest, ipv4, ipv6):
    """Determine the appopriate IP for the destination
    """

    # no preference -> return label so we allow resolving at the nodes
    if not ipv4 and not ipv6:
        return dest

    try:
        qres = query(dest, "A" if ipv4 else "AAAA")
        return str(qres.rrset[0])
    except DNSException:
        # failed to do a lookup, return the original label instead
        # could be triggered by -4 or -6 flag on an IP address
        return dest


def get_hostlist():
    """Get a list of all ring hosts.
    """
    hosts = []
    try:
        # TCP query required due to the large TXT record
        qres = query("ring.nlnog.net", "TXT", tcp=True)
        for rr in qres:
            for s in rr.strings:
                for srv in s.split(' '):
                    hosts.append(srv)
    except DNSException, e:
        return []

    return hosts


def traceroutes(hosts, destination, user, proto, udp, timeout):
    """Perform all traceroutes.
    """

    result = {}
    threads = {}
    
    # launch all threads
    for host in hosts:
        threads[host] = TraceThread(host, destination, user, proto, udp, timeout)
        threads[host].start()

    # wait for all threads to end
    for host in hosts:
        threads[host].join()

    # gather all results
    for host in hosts:
        result[host] = threads[host].get_result()

    return result


def resolve(traceroutes, resolve):
    """Lookup ASNs and FQDNs.
    """

    aslist = {}
    fqdnlist = {} 

    for host in traceroutes.keys():

        ips = [x.split(" ")[1] for x in traceroutes[host]]
        for ip in ips:
                if (ip != '???' and aslist.get(ip, 'unknown') == 'unknown'):
                    try:
                        r = reversename.from_address(ip)
                        qstr = "%s.origin%s.asn.cymru.com" % (
                            ".".join(r.to_text().split('.')[:-3]),
                            "6" if ":" in ip else "",
                        )
                        qres = query(qstr, "TXT")
                        asn = qres[0].strings[0].split(' ')[0]
                        aslist[ip] = asn
                    except:
                        aslist[ip] = 'unknown'

        if resolve or len(ips) == 0:
            lookups = ips
        else:
            lookups = [ips[0], ips[-1]]
            
        for ip in lookups:
           if (ip != '???' and fqdnlist.get(ip, 'unknown') == 'unknown'):
               try:
                   qres = query(reversename.from_address(ip).to_text(), 'PTR')
                   fqdn = qres[0].to_text()
                   fqdnlist[ip] = fqdn
               except:
                   fqdnlist[ip] = 'unknown'

    asnames = {}
    # make list of asnames
    for a in aslist.values():
        try:
            if not a in asnames.keys():
                qres = query("as%s.asn.cymru.com" % a, "TXT")
                asnames[a] = qres[0].strings[0].split('|')[4].strip().split(' ')[0]
        except:
            pass

    return (aslist, asnames, fqdnlist)


def graph(traces, destination, aslist, asnames, fqdnlist, resolve, asn, no_ixp):
    """Generate the entire graph.
    """

    result = "digraph G {"
    count = 0
    for host in traces.keys():
        ips = [x.split(" ")[1] for x in traces[host]]

        # remove IXP addresses if wanted
        if no_ixp:
            for ip in ips:
                if ":" in ip and ip != "???":
                    for ix in ixps6:
                        if IPv6Address(ip) in IPv6Network(ix):
                            while ip in ips:
                                debug("Removing %s from trace since it is an IXP address." % ip)
                                ips.remove(ip)
                elif ip != "???":
                    for ix in ixps4:
                        if IPv4Address(ip) in IPv4Network(ix):
                            ips.remove(ip)
                            while ip in ips:
                                debug("Removing %s from trace since it is an IXP address." % ip)
                                ips.remove(ip)
        
        nodes = ""
        edges = ""

        if asn:
            # asns instead of ips
            a = [aslist.get(ip, 'unknown') for ip in ips]
            # remove unkown entries
            while 'unknown' in a:
                a.remove('unknown')
            # make a list of the asns, showing each asn only once
            asns = [key for key,i in itertools.groupby(a)]

            for index in range(0, len(asns)):
                nodes = "%s node%s [shape=rectangle color=\"%s\" fontsize=8 label=\"%sAS %s\\n(%s)\" %s]" % (
                    nodes,
                    asns[index],
                    colors[count % len(colors)] if (index ==0) else "black",
                    "%s\\n" % host if index == 0 else "",
                    asns[index],
                    asnames.get(asns[index], 'unknown'),
                    "style=filled fillcolor=\"#eeeeee\" " if index ==len(asns)-1 else "",
                )

                if index < len(asns)-1:
                    edges = "%s node%s -> node%s [color=\"%s\"] " % (
                        edges, 
                        asns[index],
                        asns[index + 1],
                        colors[count % len(colors)]
                    )
        else:
            for index in range(0, len(ips)):
                nodes = "%s node%s [shape=rectangle color=\"%s\" fontsize=8 label=\"%s%s\\n(AS %s)\"]" % (
                    nodes,
                    ips[index].replace(':','_').replace('?', 'X').replace('.', '_'),
                    colors[count % len(colors)] if (index ==0) else "black",
                    ips[index],
                    "\\n%s" % fqdnlist.get(ips[index], "unknown") if (index == 0 or resolve) else "",
                    aslist.get(ips[index], 'unknown'),
                )

                if index < len(ips)-1:
                    edges = "%s node%s -> node%s [color=\"%s\"] " % (
                        edges, 
                        ips[index].replace(':','_').replace('?','X').replace('.','_'),
                        ips[index + 1].replace(':','_').replace('?','X').replace('.','_'),
                        colors[count % len(colors)]
                    )
        result = "%s %s %s " % (result, nodes, edges)
        count += 1
    result = "%s }" % result

    return result


def make_image(dot, outfile, outtype):
    """Make the actual image by running 'dot' on the generated graphviz code
    """
    fh, fname = tempfile.mkstemp(prefix='trace_')
    try:
        f = os.fdopen(fh, 'w')
        f.write(dot + "\n")
        f.close()
    except:
        print "failed to create temporary file: %s" % fname
        sys.exit(1)
       
    try:
        f = os.popen("/usr/bin/dot -T%s -o%s %s" % (outtype, outfile, fname))
        f.close()
    except:
        print "failed to exec 'dot': /usr/bin/dot -T%s -o%s %s" % (outtype, outfile, fname)
        sys.exit(1)

    try:
        os.unlink(fname)
    except:
        print "failed to clean up temporary file: %s" % fname


def debug(msg):
    """Print a string only if debugging is enabled.
    """
    if DEBUG:
        print "[%s] %s" % (time.strftime('%H:%M:%S'), msg)


if __name__ == "__main__":
    start = time.time()
    
    print "ring-trace v%s" % VERSION
    
    debug('gathering list of hosts to query.')
    hosts = get_hostlist() 
    hosts.sort()
    debug("%d hosts available" % len(hosts))

    parser = argparse.ArgumentParser(
        description="Perform a series of mtr's using the nlnog ring and visualise the results.\n\nAvailable hosts (%d): %s" % (
            len(hosts), 
            " ".join(hosts)
        ), 
        epilog="Visit http://ring.nlnog.net for more information.", 
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("destination", help="destination of the traces")
    parser.add_argument("-a", "--asn", action="store_const", dest="asn", help="group by ASN", default=False, const=True)
    parser.add_argument("-e", "--exclude", action="append", dest="exclude", help="exclude this host", default=[], metavar="HOST")
    parser.add_argument("-i", "--include", action="append", dest="include", help="include this host", default=[], metavar="HOST")
    parser.add_argument('-n', '--random', action='store', dest='random', default=-1, type=int,  help='pick a given number of hosts at random')
    parser.add_argument("-o", "--output", action="store", dest="outfile", help="output filename (trace-DESTINATION.type by default)", default="")
    parser.add_argument("-p", "--hops", action="store", dest="hops", metavar="N", type=int, help="pick top N and bottom N hosts based on hopcount", default=0)
    parser.add_argument('-r', '--resolve', action='store_const', dest='resolve', default=False, const=True,  help='try to resolve all addresses (WARNING: can take long!)')
    parser.add_argument('-t', '--type', action='store', dest='outtype', choices=('gif', 'pdf', 'png', 'jpg', 'ps', 'svg'), default='jpg', help='output filetype (jpg by default)')
    parser.add_argument("-T", "--timeout", action='store', dest='timeout', default=10, type=int, help="SSH connection timeout in seconds (10 by default)")
    parser.add_argument("-u", "--user", action="store", dest="user", help="username for SSH logins", default="")
    parser.add_argument("-U", "--udp", action="store_const", dest="udp", help="use UDP instead of ICMP ECHO", const=True, default=False)
    parser.add_argument("-v", "--verbose", action="store_const", dest="debug", help="verbose mode", const=1, default=0)
    parser.add_argument("-vv", "--extra-verbose", action="store_const", dest="debug2", help="extra verbose mode (SSH debugging)", const=2, default=0)
    parser.add_argument("-x", "--exclude-ixp", action="store_const", dest="no_ixp", help="remove IXP hops from traces", const=True, default=False)
    proto = parser.add_mutually_exclusive_group()
    proto.add_argument("-4", "--ipv4", action="store_const", dest="ipv4", help="enforce IPv4", const=True, default=False)
    proto.add_argument("-6", "--ipv6", action="store_const", dest="ipv6", help="enforce IPv6", const=True, default=False)
    ns = parser.parse_args()
    DEBUG=max(ns.debug, ns.debug2)

    debug("debugging enabled, level %d." % DEBUG)
    proto = ""
    if (ns.ipv4):
        debug('Enforcing IPv4')
        proto="-4"
    elif (ns.ipv6):
        debug('Enforcing IPv6')
        proto="-6"
    destination = fix_dest(ns.destination, ns.ipv4, ns.ipv6)

    traces = {}

    if (ns.random >= 0 and ns.random < len(hosts)):
        newlist = []
        for x in range(ns.random):
            i = random.randint(0, len(hosts) - 1)
            newlist.append(hosts[i])
            hosts.remove(hosts[i])
        hosts = newlist
        if ns.random > 0:
            print "picked %d host%s at random: %s" % (len(hosts), "s" if (ns.random > 1) else "", " ".join(hosts))

    if len(ns.exclude) > 0:
        for host in ns.exclude:
            if host in hosts:
                hosts.remove(host)
        print "Excluding %d hosts: %s" % (len(ns.exclude), " ".join(ns.exclude))

    if len(ns.include) > 0:
        for host in ns.include:
            if host not in hosts:
                hosts.append(host)
        print "Including %d hosts: %s" % (len(ns.include), " ".join(ns.include))

    if len(hosts) == 0:
        print "WARNING: The list of hosts is empty. Are you blocking TCP-based DNS request by any chance?"
        print "A TCP-based DNS query is required to retrieve the list of servers."
        print "Please specify hosts manually using the -i flag."
        sys.exit(1)

    print "Performing %s traceroutes towards %s from %d ring hosts, ssh-timeout is %d seconds." % (
        "UDP" if ns.udp else "ICMP",
        ns.destination, len(hosts), ns.timeout)
    debug('performing traces.')
    traces = traceroutes(hosts, destination, ns.user, proto, ns.udp, ns.timeout)

    if (ns.hops > 0) and (ns.hops * 2 < len(traces)):
        print "Picking top and bottom %d hosts based on hop count." % ns.hops
        # sort based on trace length
        tracelength = {}
        for trace in traces:
            tracelength[trace] = len(traces[trace])
        tsorted = sorted(tracelength.iteritems(), key=operator.itemgetter(1))
        ts = tsorted[:ns.hops] + tsorted[0-ns.hops:]
        debug("Top %d nodes based on hop length: %s" % (ns.hops, " ".join(["%s(%d)" % t for t in tsorted[:ns.hops]])))
        debug("Bottom %d nodes based on hop length: %s" % (ns.hops, " ".join(["%s(%d)" % t for t in tsorted[0-ns.hops:]])))

        newtraces = {}
        for t in ts:
            newtraces[t[0]] = traces[t[0]]
        traces = newtraces
    
    debug('generating color table')
    for c in range(0x333333, 0xdddddd, 0xaaaaaa/len(hosts)):
        colors.append("#%x" % c)

    debug('looking up hostnames and ASNs.')
    if ns.resolve:
        print "Looking up all IP addresses and ASNs, this may take quite a while."
    (aslist, asnames, fqdnlist) = resolve(traces, ns.resolve)

    debug('generating graphs.')
    dot = graph(traces, destination, aslist, asnames, fqdnlist, ns.resolve, ns.asn, ns.no_ixp)

    debug('generating output file.')
    outfile = ns.outfile

    if outfile == "":
        outfile = "trace-%s.%s" % (ns.destination, ns.outtype)
    make_image(dot, outfile, ns.outtype)

    print "Created %s in %.1f seconds." % (outfile, time.time() - start)
