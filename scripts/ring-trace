#! /usr/bin/env python
"""
 ring-trace     perform a series of mtr's towards one destination
                and visualise the results by generating an image

 Author:        Teun Vink - teun@teun.tv

 Requirements:  python, dnspython, graphviz, argparse, ipcalc, pycurl

 Changelog:
 v1.4           add pastebin option (-b)
                add more IXP ranges to check
                add support for default config in configfile
                minor fixes in debug output
 v1.3           add IXP ignore option (-x)
 v1.2           add group-by-asn option (-a)
"""

import sys, os, threading, tempfile, time, random, re, operator, itertools
import urllib, urllib2

try:
    from dns.resolver import query
    from dns import name, reversename
    from dns.exception import DNSException
    import argparse, ConfigParser
    from ipaddr import IPv4Address, IPv6Address, IPv4Network, IPv6Network, AddressValueError

except:
    print "ERROR: one or more of the following python packages is missing:"
    print "dnspython, argparse, ipaddr\n"
    print "On Ubuntu: apt-get install python-dnspython python-argparse python-ipaddr python-pycurl"
    sys.exit(1)

VERSION="1.4.0"
DEBUG=0
PASTEBIN="https://ring.nlnog.net/paste/"
CONFIGFILE=os.path.expanduser("~/.ringtrace.cfg")

colors = []

ixps4 = [
   "195.69.144.0/22", # AMS-IX
   "80.81.192.95/22", # DE-CIX
   "195.66.224.0/22", # LINX
   "193.239.116.33/23", # NL-ix
   "193.109.219.0/24", # Lipex
   "193.203.5.0/24", # Lonap
   "206.223.115.0/24", #Equinix Ashburn
   "206.223.119.0/25", #Equinix Chicago
   "206.223.118.0/25", #Equinix Dallas
   "206.223.123.0/25", #Equinix Los Angeles
   "206.223.119.0/24", #Equinix San Jose
   "198.32.176.0/24", #Equinix Palo Alto
   "198.32.182.0/24", #Equinix Atlanta
   "198.32.190.0/24", #Equinix Vienna, VA
   "198.32.134.0/24", #Equinix Seattle
   "198.32.118.0/24", #Equinix New York
   "198.32.180.0/24", #SIX
   "198.32.160.0/24", #NYIIX
   "198.32.187.0/24", #MAE East
   "198.32.200.0/24", #MAE West
   "198.32.124.0/23", #NOTA
   "198.32.139.0/24", #MAE Central
   "198.32.212.0/24", #WAIX
   "198.32.132.0/24", #Telx Atlanta
   "198.32.146.0/24", #LAIIX
   "198.32.245.0/24", #TorIX
   "198.32.178.0/24", #MXP
   "194.42.48.0/24", #Equinix Zurich
   "198.32.129.0/24", #SFIX
   "192.65.185.0/24", #CIXP
   "194.68.129.0/24", #SFINX
   "217.29.66.0/24", #MIX-IT
   "213.228.3.128/25", #FreeIX
   "198.32.247.0/24", #PARIX
   "198.32.229.0/24", #NYCX
   "202.40.161.0/24", #HKIX
   "210.62.255.0/24", #TWIX
   "202.0.91.0/24", #Manila IX
   "193.1.29.192/27", #INEX LAN1
   "193.203.0.0/25", #VIX
   "217.79.160.0/23", #XchangePoint
   "192.145.251.0/24", #KINX
   "193.188.137.0/24", #BiX
   "193.25.170.0/23", #RBIEX
   "212.121.32.0/19", #Edge-IX
   "195.85.203.0/24", #FreeBIX
   "194.53.172.0/25", #BNIX
   "194.242.34.14/25", #SwissIX
   "213.234.0.0/25", #CATNIX
   "193.149.0.0/24", #ESPANIX
   "198.32.131.0/24", #KD-X
   "80.67.175.0/26", #Pouix
   "195.140.149.129/25", #FNIX6
   "194.153.157.192/26", #Lyonix
   "194.68.123.0/24", #NetNod Stockholm
   "194.68.128.0/24", #NetNod Stockholm
   "194.50.100.0/24", #NIX CZ
   "194.59.190.0/24", #INXS
   "213.238.34.0/24", #WORK-IX
   "193.111.172.0/24", #GN-IX
   "193.168.127.0/24", #LIX
   "192.38.7.0/24", #DIX
   "198.17.46.0/24", #SD-NAP
   "207.231.241.0/24", #PacificWave
   "193.156.90.0/24", #NIX
   "192.108.148.0/24", #SIX.SK
   "193.108.98.0/24", #NDIX
   "193.178.185.0/24", #B-CIX
   "210.184.127.0/24", #iAIX
   "144.92.233.224/28", #MadIX
   "195.245.196.0/24", #MAD-IX
   "194.146.118.0/24", #ECIX Duesseldorf
   "202.167.228.0/24", #Equinix Sydney
   "195.85.195.0/24", #WIX
   "195.242.64.0/23", #UNION IXP
   "193.232.244.0/22", #MSK-IX
   "218.100.2.0/24", #PIPE Networks Sydney
   "194.85.177.0/24", #SPB-IX
   "69.51.84.0/26", #NWIX Helena
   "69.51.84.128/26", #NWIX Missoula
   "218.100.0.0/24", #PIPE Networks Brisbane
   "218.100.13.0/24", #PIPE Networks Melbourne
   "218.100.19.0/24", #PIPE Networks Canberra
   "218.100.12.0/24", #PIPE Networks Hobart
   "194.116.96.0/19", #TOP-IX
   "62.35.254.0/24", #PaNAP
   "193.201.28.0/23", #NaMeX
   "192.77.55.0/25", #QiX 3
   "193.189.82.0/24", #KleyReX
   "198.32.146.0/24", #CIIX (formerly LAAP)
   "218.100.6.0/24", #BBIX
   "198.32.162.0/24", #OIX
   "193.110.12.0/24", #SOL-IX / SOLIX
   "193.110.13.0/24", #SOL-IX / SOLIX
   "193.108.17.0/24", #SOL-IX / SOLIX
   "198.32.142.0/24", #JINX
   "198.32.185.0/24", #PHX-IX
   "195.85.217.0/24", #N-IX
   "198.32.198.0/24", #TampaIX
   "206.223.143.0/24", #CoreSite - Any2 Los Angeles
   "194.165.32.0/24", #GIX Gothenburg
   "80.67.163.0/24", #GEIX
   "198.32.238.0/24", #BigApe
   "208.50.192.0/24", #IXNM
   "202.78.121.0/24", #BAYANTEL
   "83.245.126.0/30", #PacketExchange
   "85.31.223.0/24", #MA-IX
   "195.60.84.128/25", #MerieX
   "198.32.195.0/24", #NWAX
   "83.245.126.0/23", #eXpress
   "203.190.230.0/24", #Equinix Tokyo
   "198.32.252.0/24", #AMPATH
   "194.54.92.0/25", #OCIX Duesseldorf
   "194.50.181.0/24", #STHIX
   "200.0.17.0/24", #CABASE
   "194.116.188.0/24", #TIX-LAN
   "195.137.179.0/24", #TLLIX
   "194.68.130.0/24", #Netnod Gothenburg
   "195.69.116.0/24", #Netnod Gothenburg
   "195.69.117.0/24", #Netnod Malmo
   "195.69.118.0/24", #Netnod Malmo
   "194.68.133.0/24", #Netnod Sundsvall
   "194.68.135.0/24", #Netnod Sundsvall
   "206.223.127.0/25", #PIX Vancouver
   "206.223.139.0/26", #PIX Montreal
   "206.223.127.128/25", #PIX Toronto
   "198.32.202.0/24", #NIXI Delhi
   "192.168.100.0/24", #YRIX
   "206.51.40.0/24", #CoreSite - Any2 DC
   "206.51.44.0/24", #CoreSite - Any2 Miami
   "78.41.189.128/26", #PhibIX
   "202.125.128.0/19", #PTCL (PIE)
   "193.189.130.0/24", #ENLIX
   "194.9.117.0/24", #ECIX Berlin
   "218.100.4.0/24", #IIX
   "198.32.167.0/24", #BDIX
   "198.32.235.0/24", #OttIX
   "193.232.87.0/24", #NSK-IX
   "206.51.43.0/24", #CoreSite - Any2 Chicago
   "198.32.172.0/24", #PHOpenIX
   "193.4.58.0/27", #RIX
   "193.84.179.0/24", #PIX - Poznan
   "193.243.183.64/26", #MalmIX Malmo / IXOR
   "80.248.213.128/27", #StuffIX Paris
   "202.249.38.0/24", #NSPIXP3
   "218.100.48.0/24", #NIXI Chennai
   "198.32.143.0/24", #KIXP
   "202.97.10.0/24", #CNC Beijing NAP
   "198.32.149.0/24", #Ottawa GigaPOP
   "206.51.33.0/24", #ChIX
   "92.60.70.0/24", #MINAP Milan
   "198.32.231.0/24", #npIX
   "80.81.202.0/24", #ALP-IX
   "206.51.7.0/24", #KCIX Kansas City
   "218.100.44.0/24", #MyIX
   "206.223.124/24", #NAP Colombia - CCIT
   "200.1.6.0/24", #NAP.EC
   "198.32.216.0/24", #RMIX Denver
   "195.42.144.0/24", #Equinix Paris
   "198.32.186.0/24", #Telx Phoenix
   "194.68.131.64/26", #Netnod Lulea
   "212.32.128.0/25", #Norrnod
   "200.0.22.0/23", #OCIX
   "198.180.153.0/24", #SISPA
   "195.182.218/23", #PLIX
   "206.197.210.0/24", #DRF IX
   "218.100.50.0/25", #TransACT IX
   "86.104.125.0/24", #INTERLAN
   "193.42.140.0/24", #TIX
   "81.21.96.0/24", #CAIX
   "192.168.255.0/24", #BY-IX
   "189.45.5.0/24", #PTTMETRO Botafogo
   "196.223.7.0/24", #MEIX
   "195.189.188.0/25", #UppRIX
   "195.189.189.0/25", #UppRIX
   "195.189.188.128/25", #UppRIX
   "195.60.93.0/26", #Crimea-IX
   "218.100.59.0/24", #ACTIX
   "193.42.155.0/24", #ECIX Hamburg
   "194.107.117.0/24", #Od-IX
   "202.158.0.0/17", #CBN Exchange Point
   "82.148.16.0/24", #NET-IX
   "193.156.120.0/24", #NIX2
   "194.30.187.0/24", #Sitelix
   "217.156.113.0/24", #RoNIX
   "193.192.15.64/26", #CIX
   "212.5.48.0./22", #SofiaConn
   "200.219.144.0/24", #PTTMETRO Londrina
   "2001:7f8:4d::/48", #ExWest
   "193.2.141.0/24", #SIX SI
   "89.40.130.0/24", #TomIX
   "114.141.48.0/21", #CyberPlus
   "195.140.192.0/24", #TREX
   "91.213.73.0/24", #CNIX
   "193.169.198.0/23", #BIX.BG
   "195.2.230.0/23", #KAZ-IX
   "91.213.236.0/24", #TOUIX
   "206.51.41.0/24", #CoreSite - Any2 Silicon Valley
   "83.217.20.0/26", #ULN-IX
   "93.156.93.0/24", #TRDIX
   "198.32.214.0/24", #CINX
   "189.76.208.0/20", #WKVE
   "83.212.8.0/23", #GR-IX
   "194.85.107.0/24", #EKT-IX
   "192.77.55.0/24", #QIX
   "78.111.112.0/20", #GRAPESC
   "93.91.144.0/20", #GRAPESC
   "109.72.0.0/20", #GRAPESC
   "188.227.0.0/22", #dataix
   "196.223.5.0/25", #TIX - Tanzania
   "209.33.201.176/28", #SUPRnet
   "195.246.227.0/24", #SMILE-LV
   "200.0.20.0/23", #CAR-IX
   "193.136.251.96/27", #GigaPix OPorto
   "218.100.27.0/24 ", #OpenIXP / NiCE
   "218.100.36.0/24", #OpenIXP / NiCE
   "193.37.144.0/24", #AAIX
   "193.232.136.0/24", #VLV-IX
   "193.232.135.0/24", #SMR-IX
   "193.232.140.0/24", #RND-IX
   "193.57.253.128/27", #REUNIX
   "62.63.140.0/22", #LIX-LV
   "194.88.240.0/25", #INEX LAN2
   "193.17.78.0/24", #MD-IX
   "192.114.62.0/23", #IIX_
   "204.228.158.0/27", #UTOPIA
   "194.190.119.0/24", #KZN-IX
   "193.219.13.64/26", #LIPTAM
   "216.72.175.0/24", #NAP Chile
   "91.216.67.0/24", #FR-IX
   "202.85.224.0/20", #Powernetix
   "196.223.1.0/24", #Angola-IXP / ANG-IXP
   "194.153.153.0/24", #UIXP
   "193.105.163.0/24", #SOX d.o.o. Serbia
   "198.32.136.0/24", #NASA-AIX
   "198.32.153.0/24", #NASA-AIX
   "198.9.201.0/24", #NASA-AIX
   "198.9.202.0/24", #NASA-AIX
   "218.100.70.0/24", #SGIX
   "193.105.214.0/24", #GraX
   "218.100.41.0/24", #BIXc
   "91.198.176.0/24", #Fixo
   "194.117.52.128/25", #COPHIX
   "119.110.116.0/23", #MCIX - Matrix Networks
   "91.212.9.0/24", #KIX
   "91.192.104.0/23", #Lviv-IX
   "206.223.120.0/24", #AZIX
   "195.60.89.0/25", #CBIX
   "212.91.0.0/22", #Thinx
   "195.149.232.0/21", #TP-IX
   "196.216.148.0/24", #IXPN Lagos
   "195.191.170.0/23", #EPIX
   "195.149.232.0/23", #TPIX
   "188.116.45.0/24", #GIX Gdansk
   "193.28.6.0/24", #PIRIX
   "218.100.78.0/24", #VIC-IX
   "206.197.131.0/24", #COIX
   "196.223.24.0/24", #LIXP
   "192.168.10.0/24", #MOZIX
   "217.117.187.0/24", #KRS-IX
   "80.81.201.0/24", #DE-CIX Duesseldorf
   "193.105.116.0/24", #Content-IX
   "213.184.52.0/24", #RTIX
   "81.16.231.0/25", #Litix
   "91.232.229.0/24", #Rheintal IX
   "200.219.144/22", #PTTMETRO Salvador
   "192.108.145.0/24", #SIX.SK Kosice
   "206.123.7.0/24", #JXIX
   "206.108.236.0/24", #Boston Internet Exchange
   "218.100.21.0/24", #PNIX
]

ixps6 = [
    "2001:7f8::/29",            # generic IXP
    "2001:470:1f07:cff::/64",   # pix.net.pl
]


class TraceThread(threading.Thread):

    def __init__(self, host, destination, user, proto, udp, timeout):
        self.starttime = time.time()
        self.host = host
        self.dest = destination
        self.user = user
        self.proto = proto
        self.udp = udp
        self.timeout = timeout
        self.result  = ""
        threading.Thread.__init__(self)

    
    def run(self):
        # run the mtr command
        cmd = "ssh %s -o ConnectTimeout=%d %s %s.ring.nlnog.net \"mtr %s --report-wide -c1 -r -n %s %s\"" % (
            "-v" if DEBUG > 1 else "",
            self.timeout,
            "-l %s" % self.user if self.user != None else "",
            self.host, self.proto, 
            "-u" if self.udp else "",
            self.dest,
        )
        f = os.popen(cmd)
        lines = [l.strip() for l in f.readlines()][1:]
        f.close()

        # lookup the IP for the host
        qstr = "%s.ring.nlnog.net" % self.host
        qtype = "A"

        # IPv6 literal or forced IPv6
        if (":" in self.dest) or (self.proto == "-6"):
            qtype="AAAA"

        # check if the host has an AAAA record
        if qtype == "A":
            try:
                query(self.dest, "AAAA")
                qtype = "AAAA"
            except:
                qtype = "A"

        try:
            qres = query(qstr, qtype)
        except:
            qres = [qstr]

        # add the host as first hop so the graphs are easier to understand
        lines.insert(0, "0. %s" % qres[0]) 

        self.result = lines

        debug("host %s done in %.1f seconds." % (self.host, time.time() - self.starttime))


    def get_result(self):
        return self.result


def fix_dest(dest, ipv4, ipv6):
    """Determine the appopriate IP for the destination
    """

    # no preference -> return label so we allow resolving at the nodes
    if not ipv4 and not ipv6:
        return dest

    try:
        qres = query(dest, "A" if ipv4 else "AAAA")
        return str(qres.rrset[0])
    except DNSException:
        # failed to do a lookup, return the original label instead
        # could be triggered by -4 or -6 flag on an IP address
        return dest


def get_hostlist():
    """Get a list of all ring hosts.
    """
    hosts = []
    try:
        # TCP query required due to the large TXT record
        qres = query("ring.nlnog.net", "TXT", tcp=True)
        for rr in qres:
            for s in rr.strings:
                for srv in s.split(' '):
                    hosts.append(srv)
    except DNSException, e:
        return []

    return hosts


def traceroutes(hosts, destination, user, proto, udp, timeout):
    """Perform all traceroutes.
    """

    result = {}
    threads = {}
    
    # launch all threads
    for host in hosts:
        threads[host] = TraceThread(host, destination, user, proto, udp, timeout)
        threads[host].start()

    # wait for all threads to end
    for host in hosts:
        threads[host].join()

    # gather all results
    for host in hosts:
        result[host] = threads[host].get_result()

    return result


def resolve(traceroutes, resolve):
    """Lookup ASNs and FQDNs.
    """

    aslist = {}
    fqdnlist = {} 
    lookup_ok = 0
    lookup_fail = 0

    for host in traceroutes.keys():

        ips = [x.split(" ")[1] for x in traceroutes[host]]
        for ip in ips:
                if (ip != '???' and aslist.get(ip, 'unknown') == 'unknown'):
                    try:
                        r = reversename.from_address(ip)
                        qstr = "%s.origin%s.asn.cymru.com" % (
                            ".".join(r.to_text().split('.')[:-3]),
                            "6" if ":" in ip else "",
                        )
                        qres = query(qstr, "TXT")
                        asn = qres[0].strings[0].split(' ')[0]
                        aslist[ip] = asn
                        lookup_ok += 1
                    except:
                        aslist[ip] = 'unknown'
                        lookup_fail += 1

        if resolve or len(ips) == 0:
            lookups = ips
        else:
            lookups = [ips[0], ips[-1]]
            
        for ip in lookups:
           if (ip != '???' and fqdnlist.get(ip, 'unknown') == 'unknown'):
               try:
                   qres = query(reversename.from_address(ip).to_text(), 'PTR')
                   fqdn = qres[0].to_text()
                   fqdnlist[ip] = fqdn
                   lookup_ok += 1
               except:
                   fqdnlist[ip] = 'unknown'
                   lookup_fail += 1 

    debug("%d successful IP lookups, %d failed." % (lookup_ok, lookup_fail))
    asnames = {}
    # make list of asnames
    for a in aslist.values():
        try:
            if not a in asnames.keys():
                qres = query("as%s.asn.cymru.com" % a, "TXT")
                asnames[a] = qres[0].strings[0].split('|')[4].strip().split(' ')[0]
        except:
            pass

    return (aslist, asnames, fqdnlist)


def graph(traces, destination, aslist, asnames, fqdnlist, resolve, asn, no_ixp):
    """Generate the entire graph.
    """

    result = "digraph G {"
    count = 0
    for host in traces.keys():
        ips = [x.split(" ")[1] for x in traces[host]]

        # remove IXP addresses if wanted
        if no_ixp:
            for ip in ips:
                if ":" in ip and ip != "???":
                    for ix in ixps6:
                        try:
                            if IPv6Address(ip) in IPv6Network(ix):
                                while ip in ips:
                                    debug("Removing %s from trace since it is an IXP address." % ip)
                                    ips.remove(ip)
                        except AddressValueError:
                            pass
                elif ip != "???":
                    for ix in ixps4:
                        try:
                            if IPv4Address(ip) in IPv4Network(ix):
                                while ip in ips:
                                    debug("Removing %s from trace since it is an IXP address." % ip)
                                    ips.remove(ip)
                        except AddressValueError:
                            pass
        
        nodes = ""
        edges = ""

        if asn:
            # asns instead of ips
            a = [aslist.get(ip, 'unknown') for ip in ips]
            # remove unkown entries
            while 'unknown' in a:
                a.remove('unknown')
            # make a list of the asns, showing each asn only once
            asns = [key for key,i in itertools.groupby(a)]

            for index in range(0, len(asns)):
                nodes = "%s node%s [shape=rectangle color=\"%s\" fontsize=8 label=\"%sAS %s\\n(%s)\" %s]" % (
                    nodes,
                    asns[index],
                    colors[count % len(colors)] if (index ==0) else "black",
                    "%s\\n" % host if index == 0 else "",
                    asns[index],
                    asnames.get(asns[index], 'unknown'),
                    "style=filled fillcolor=\"#eeeeee\" " if index ==len(asns)-1 else "",
                )

                if index < len(asns)-1:
                    edges = "%s node%s -> node%s [color=\"%s\"] " % (
                        edges, 
                        asns[index],
                        asns[index + 1],
                        colors[count % len(colors)]
                    )
        else:
            for index in range(0, len(ips)):
                nodes = "%s node%s [shape=rectangle color=\"%s\" fontsize=8 label=\"%s%s\\n(AS %s)\"]" % (
                    nodes,
                    ips[index].replace(':','_').replace('?', 'X').replace('.', '_'),
                    colors[count % len(colors)] if (index ==0) else "black",
                    ips[index],
                    "\\n%s" % fqdnlist.get(ips[index], "unknown") if (index == 0 or resolve) else "",
                    aslist.get(ips[index], 'unknown'),
                )

                if index < len(ips)-1:
                    edges = "%s node%s -> node%s [color=\"%s\"] " % (
                        edges, 
                        ips[index].replace(':','_').replace('?','X').replace('.','_'),
                        ips[index + 1].replace(':','_').replace('?','X').replace('.','_'),
                        colors[count % len(colors)]
                    )
        result = "%s %s %s " % (result, nodes, edges)
        count += 1
    result = "%s }" % result

    return result


def make_image(dot, outfile, outtype, pastebin, dest, traces):
    """Make the actual image by running 'dot' on the generated graphviz code
    """
    fh, fname = tempfile.mkstemp(prefix='trace_')
    try:
        f = os.fdopen(fh, 'w')
        f.write(dot + "\n")
        f.close()
    except:
        print "failed to create temporary file: %s" % fname
        sys.exit(1)
    
    if pastebin:
        outtype = "png"
    try:
        f = os.popen("/usr/bin/dot -T%s -o%s %s" % (outtype, outfile, fname))
        f.close()
    except:
        print "failed to exec 'dot': /usr/bin/dot -T%s -o%s %s" % (outtype, outfile, fname)
        sys.exit(1)

    if not os.path.exists(outfile):
        print "failed to generate image."
        sys.exit(1)

    try:
        os.unlink(fname)
    except:
        print "failed to clean up temporary file: %s" % fname

    if pastebin:
        debug("sending file to pastebin...")

        postarray = [
            ("content", file(outfile).read()),
            ("mimetype", "image/png"),
            ("ttl", 604800)
            ]
        postdata = urllib.urlencode(postarray)
        try:
            req = urllib2.Request(url="https://ring.nlnog.net/paste/", data=postdata)   
            result = urllib2.urlopen(req)
            print "\nImage uploaded to %s" % result.url
        except:
            print "failed to upload the image to the pastebin."
            sys.exit(1)

        try:
            os.unlink(outfile)
        except:
            print "failed to clean up temporary file: %s" % outfile
    else:
        print "Created file: %s" % outfile



def debug(msg):
    """Print a string only if debugging is enabled.
    """
    if DEBUG:
        print "[%s] %s" % (time.strftime('%H:%M:%S'), msg)


def read_config():
    """Parse a configfile.
    """
    debug("reading configfile")
    cfg = ConfigParser.ConfigParser()
    cfg.read(CONFIGFILE)

    # here is our default config
    config = {
        "groupbyasn":   False,          # flag: -a, --asn
        "pastebin":     False,          # flag: -b, --pastebin
        "excludehosts": [],             # flag: -e, --exclude
        "includehosts": [],             # flag: -i, --include
        "usenodes":     -1,             # flag: -n, --random
        "filename":     None,           # flag: -o, --outfile
        "topnodes":     0,              # flag: -p, --hops
        "resolve":      False,          # flag: -r, --resolve
        "report":       False,          # flag: -R, --report
        "filetype":     "jpg",          # flag: -t, --type
        "sshtimeout":   10,             # flag: -T, --timeout
        "user":         None,           # flag: -u, --user
        "udp":          False,          # flag: -U, --udp
        "verbose":      0,              # flag: -v / -vv, --verbose, --extra-verbose
        'excludeixp':   False,          # flag: -x, --exclude-ixp
        "ipv4":         False,          # flag: -4, --ipv4
        "ipv6":         False,          # flag: -6, --ipv6
    }

    conftypes = {
        "groupbyasn" : "bool",    
        "pastebin" : "bool",      
        "includehosts" : "list",
        "excludehosts": "list",   
        "usenodes" : "int",       
        "filename" : "str",
        "topnodes" : "int",       
        "resolve" : "bool",       
        "report" : "bool",
        "filetype" : "enum:gif,jpg,pdf,png,ps,svg",
        "sshtimeout" : "int",     
        "user" : "str",           
        "udp" : "bool",
        "verbose" : "int",        
        "excludeixp" : "bool",    
        "ipv4" : "bool",
        "ipv6" : "bool" 
    }

    try:
        options = cfg.options('Config')
        debug("read default settings from '%s'"  % CONFIGFILE)
    except ConfigParser.NoSectionError:
        # incorrect or non-existing config file, return defaults
        debug("configfile %s not found, using default values" % CONFIGFILE)
        return config

    for option in options:
        if option in config.keys():
            if conftypes[option] == "bool":
                config[option] = cfg.get('Config', option).lower() == "true"
            elif conftypes[option] == "int":
                    config[option] = int(cfg.get('Config', option))
            elif conftypes[option] == "str":
                    config[option] = cfg.get('Config', option)
            elif conftypes[option] == "list":
                rhs = cfg.get('Config',option)
                if rhs:
                    config[option] = [x.strip() for x in cfg.get('Config', option).split(',')] if "," in cfg.get('Config', option) else [rhs]
            elif conftypes[option][:4] == "enum":
                options = conftypes[option][5:].split(',')
                if cfg.get('Config', option).lower() in options:
                    config[option] = cfg.get('Config', option)
                else:
                    print "invalid value '%s' for %s, allowed: %s" % (
                        cfg.get('Config', option), option, ', '.join(options))

            else:
                print "invalid type for %s: %s instead of expected %s" % (
                    option, type(cfg.get('Config', option)), conftypes[option])

    return config


def show_report(traces, destination):
    """print a report of the results.
    """

    print len(traces)

if __name__ == "__main__":
    start = time.time()
    
    print "ring-trace v%s - written by Teun Vink <teun@teun.tv>" % VERSION

    # set debugging before we start argparsing
    if ('-v' in sys.argv) or ('--verbose' in sys.argv) or ('-vv' in sys.argv) or ('--extra-verbose' in sys.argv):
        DEBUG = 1

    debug("debugging enabled.")
    
    debug('gathering list of hosts to query.')
    hosts = get_hostlist() 
    hosts.sort()
    debug("%d hosts available" % len(hosts))

    conf = read_config()
    debug("base config: \n%s" % "\n".join(["  - %s: %s" % (x, conf[x]) for x in conf.keys()]))

    parser = argparse.ArgumentParser(
        description="Perform a series of mtr's using the nlnog ring and visualise the results.\n\nAvailable hosts (%d): %s" % (
            len(hosts), 
            " ".join(hosts)
        ), 
        epilog="Visit http://ring.nlnog.net for more information.", 
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("destination", help="destination of the traces")
    parser.add_argument("-a", "--asn", action="store_const", dest="asn", help="group by ASN", default=conf['groupbyasn'], const=True)
    parser.add_argument("-b", "--pastebin", action="store_const", dest="pastebin", help="send output to a pastebin", default=conf['pastebin'], const=True)
    parser.add_argument("-e", "--exclude", action="append", dest="exclude", help="exclude this host", default=conf['excludehosts'], metavar="HOST")
    parser.add_argument("-i", "--include", action="append", dest="include", help="include this host", default=conf['includehosts'], metavar="HOST")
    parser.add_argument('-n', '--random', action='store', dest='random', default=conf['usenodes'], type=int,  help='pick a given number of hosts at random')
    parser.add_argument("-o", "--output", action="store", dest="outfile", help="output filename (trace-DESTINATION.type by default)", default=conf['filename'])
    parser.add_argument("-p", "--hops", action="store", dest="hops", metavar="N", type=int, help="pick top N and bottom N hosts based on hopcount", default=conf['topnodes'])
    parser.add_argument('-r', '--resolve', action='store_const', dest='resolve', default=False, const=conf["resolve"],  help='try to resolve all addresses (WARNING: can take long!)')
    parser.add_argument('-R', '--report', action='store_const', dest='report', default=False, const=conf["report"],  help='show a report of the results')
    parser.add_argument('-t', '--type', action='store', dest='outtype', choices=('gif', 'pdf', 'png', 'jpg', 'ps', 'svg'), default=conf['filetype'], help='output filetype (jpg by default)')
    parser.add_argument("-T", "--timeout", action='store', dest='timeout', default=int(conf['sshtimeout']), type=int, help="SSH connection timeout in seconds (10 by default)")
    parser.add_argument("-u", "--user", action="store", dest="user", help="username for SSH logins", default=conf['user'])
    parser.add_argument("-U", "--udp", action="store_const", dest="udp", help="use UDP instead of ICMP ECHO", const=True, default=conf['udp'])
    parser.add_argument("-v", "--verbose", action="store_const", dest="debug", help="verbose mode", const=1, default=int(conf['verbose']))
    parser.add_argument("-vv", "--extra-verbose", action="store_const", dest="debug2", help="extra verbose mode (SSH debugging)", const=2, default=int(conf['verbose']))
    parser.add_argument("-x", "--exclude-ixp", action="store_const", dest="no_ixp", help="remove IXP hops from traces", const=True, default=conf['excludeixp'])
    proto = parser.add_mutually_exclusive_group()
    proto.add_argument("-4", "--ipv4", action="store_const", dest="ipv4", help="enforce IPv4", const=True, default=conf['ipv4'])
    proto.add_argument("-6", "--ipv6", action="store_const", dest="ipv6", help="enforce IPv6", const=True, default=conf['ipv6'])
    ns = parser.parse_args()
    proto = ""
    if (ns.ipv4):
        debug('Enforcing IPv4')
        proto="-4"
    elif (ns.ipv6):
        debug('Enforcing IPv6')
        proto="-6"
    destination = fix_dest(ns.destination, ns.ipv4, ns.ipv6)

    traces = {}

    if (ns.random >= 0 and ns.random < len(hosts)):
        newlist = []
        for x in range(ns.random):
            i = random.randint(0, len(hosts) - 1)
            newlist.append(hosts[i])
            hosts.remove(hosts[i])
        hosts = newlist
        if ns.random > 0:
            print "picked %d host%s at random: %s" % (len(hosts), "s" if (ns.random > 1) else "", " ".join(hosts))

    if len(ns.exclude) > 0:
        for host in ns.exclude:
            if host in hosts:
                hosts.remove(host)
        print "Excluding %d hosts: %s" % (len(ns.exclude), " ".join(ns.exclude))

    if len(ns.include) > 0:
        for host in ns.include:
            if host not in hosts:
                hosts.append(host)
        print "Including %d hosts: %s" % (len(ns.include), " ".join(ns.include))

    if len(hosts) == 0:
        print "WARNING: The list of hosts is empty. Are you blocking TCP-based DNS request by any chance?"
        print "A TCP-based DNS query is required to retrieve the list of servers."
        print "Please specify hosts manually using the -i flag."
        sys.exit(1)

    print "Performing %s traceroutes towards %s from %d ring hosts, ssh-timeout is %d seconds." % (
        "UDP" if ns.udp else "ICMP",
        ns.destination, len(hosts), ns.timeout)
    debug('performing traces.')
    traces = traceroutes(hosts, destination, ns.user, proto, ns.udp, ns.timeout)

    if (ns.hops > 0) and (ns.hops * 2 < len(traces)):
        print "Picking top and bottom %d hosts based on hop count." % ns.hops
        # sort based on trace length
        tracelength = {}
        for trace in traces:
            tracelength[trace] = len(traces[trace])
        tsorted = sorted(tracelength.iteritems(), key=operator.itemgetter(1))
        ts = tsorted[:ns.hops] + tsorted[0-ns.hops:]
        debug("Top %d nodes based on hop length: %s" % (ns.hops, " ".join(["%s(%d)" % t for t in tsorted[:ns.hops]])))
        debug("Bottom %d nodes based on hop length: %s" % (ns.hops, " ".join(["%s(%d)" % t for t in tsorted[0-ns.hops:]])))

        newtraces = {}
        for t in ts:
            newtraces[t[0]] = traces[t[0]]
        traces = newtraces
    
    debug('generating color table')
    for c in range(0x333333, 0xdddddd, 0xaaaaaa/len(hosts)):
        colors.append("#%x" % c)

    debug('looking up hostnames and ASNs.')
    if ns.resolve:
        print "Looking up all IP addresses and ASNs, this may take quite a while."
    (aslist, asnames, fqdnlist) = resolve(traces, ns.resolve)

    debug('generating graphs.')
    dot = graph(traces, destination, aslist, asnames, fqdnlist, ns.resolve, ns.asn, ns.no_ixp)

    debug('generating output file.')
    outfile = ns.outfile

    if not outfile:
        outfile = "trace-%s.%s" % (ns.destination, ns.outtype)
    make_image(dot, outfile, ns.outtype, ns.pastebin, destination, traces)

    if ns.report:
        show_report(traces, destination)

    print "Done in %.1f seconds." % (time.time() - start)
