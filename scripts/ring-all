#!/usr/bin/env ruby

# ytti@iki.fi

module Ring
require 'open3'
require 'etc'
Domain  = 'ring.nlnog.net'
Timeout = 10
SSH     = 'ssh -q -t '
User    = Etc.getlogin
Date    = Time.now.utc.strftime '%Y-%m-%d %H:%M:%S (UTC)'
NodeCMD = %x(dig ring.nlnog.net txt +short +tcp|tr -d '"'|tr ' ' '\n')

# returns list of ring nodes
def self.nodes
  #TODO: replace with pure ruby, once we have new enough ruby to handle TCP in resolv module
  NodeCMD.split "\n"
  #%w(tdc01 widexs01 duocast01 msp01)
end

# runs ssh to each node in parallel, returns hash with nodes as keys and array of output and end time
def self.all cmd, timeout=Timeout
  output = {}
  end_time = {}
  threads = []
  Ring.nodes.each do |node|
    output[node] = []
    threads << [Thread.new { end_time[node] = Ring.ssh node, cmd, output[node] }, node]
  end
  if timeout == 0
    sleep 0.1 while threads.any? { |t| t.first.alive? }
  else
    start = Time.now
    sleep 0.1 while threads.any? { |t| t.first.alive? } and start+timeout > Time.now
  end
  unfinished = []
  threads.each { |t| unfinished << t.last if t.first.alive? }
  [output, end_time, unfinished]
end

# runs command via ssh in node and returns array containing output in array and time when finished
def self.ssh node, cmd, output
  cmd = Ring::SSH + [node, cmd].join(' ')
  Open3.popen3(cmd) do |stdin, stdout, stderr, wait_thr|
    while line_err = stderr.gets or line_out = stdout.gets
      output << '**'+line_err.chomp+"**\n" if line_err
      output << line_out if line_out
    end
  end
  Time.now
end

# runs command in each node, reporting if command was success and latency of node
def self.health
  out = ''
  start = Time.now
  output, end_time, unfinished = all 'echo xyzzy42'
  output.each do |node, output|
    stop = end_time[node] ? "%3fs" % (end_time[node]-start) : 'NaN'
    out << "%23s %s %s\n" % [node, output==["xyzzy42\n"] ? 'ACK' : 'NAK', stop]
  end
  out
end

# return formatted string of ssh command of each node
def self.all_str cmd, timeout=Timeout
  out = ''
  start = Time.now
  output, end_time, unfinished = all cmd, timeout

  out << str = 'RING report - ' + cmd + "\n"
  out << "=" * str.size + "\n"
  out << '* Executed on behalf of: ' + Ring::User + "\n"
  out << '* Date: ' + Ring::Date + "\n"
  out << "* Executed on: #{output.size} nodes, #{unfinished.size} node(s) timed-out or were unreachable.\n"
  out << "* For more information about the RING, visit <http://ring.nlnog.net>\n"
  output.each do |node, output|
    out << "\n"
    
    delay = unfinished.index(node) ? 'timeout' : '%.3f' % (end_time[node]-start) + 's'
    out << str = "%s (%s) - \'%s\'\n" % [node, delay, cmd]
    out << '-' * str.size + "\n"
    output.each {|line| out << ' ' * 4 + line}
  end
  out 
end

# I really didn't intend this to be CLI, but library, but silly front-end included
class CLI
  def initialize
    require 'optparse'
    cfg = {
     :timeout => Timeout,
    }
    args = nil
    begin
      cfg, args = parseOptions cfg
    rescue => e
      puts "Error: " + e
      exit 
    end
    if cfg[:mode]
      puts Ring.health
    elsif cfg[:output]
      p Ring.all args.join(' '), cfg[:timeout]
    else
      puts Ring.all_str args.join(' '), cfg[:timeout]
    end
  end

  def parseOptions cfg
    opts = OptionParser.new do |opt|
      opt.banner = 'Usage: ' + $0 + " [options] <cmd>"
      opt.on('-t', '--timeout [TIMEOUT]', 'set timeout, default is ' + Ring::Timeout.to_s) { |v| cfg[:timeout] = v.to_i }
      opt.on('-m', '--machine', 'use machine output, instead of markdown') { cfg[:output] = 'machine' }
      opt.on('-s', '--status', 'report health') { cfg[:mode] = 'health' }
      opt.on_tail('-h', '--help', 'show this message') { puts opt; exit }
    end
    args = opts.order!
    raise ArgumentError, 'parameter missing, try --help' if args.size < 1 and not cfg[:mode]
    [cfg, args]
  end
end

end

Ring::CLI.new if __FILE__ == $0
